\chapter{Code} % Main appendix title

\label{AppendixA} 
\begin{sloppypar}
\lstset{
  language=Python,
  backgroundcolor=\color{lightgray},
  basicstyle=\ttfamily\footnotesize,
  breaklines=true,
  commentstyle=\color{green},
  keywordstyle=\color{blue},
  stringstyle=\color{red},
}


\subsection{Image Degradation Code in Python}


\section*{Code for Degradation Simulation}

\begin{lstlisting}[language=Python]
import os
import cv2
import numpy as np
import random
from typing import Tuple
from glob import glob

class DegradationModels:
    def __init__(self, target_size: Tuple[int, int] = (512, 512)):
        self.target_size = target_size
        self.ffhq_path = "inputs/originals"
        self.output_path = "inputs/degraded"
        os.makedirs(self.output_path, exist_ok=True)

    def _resize_image(self, image: np.ndarray) -> np.ndarray:
        return cv2.resize(image, self.target_size)

    def _apply_gaussian_blur(self, image: np.ndarray, kernel_size: int = 0, sigma: float = 0) -> np.ndarray:
        if kernel_size == 0:
            kernel_size = int(2 * np.ceil(2 * sigma) + 1)
        if kernel_size % 2 == 0:
            kernel_size += 1
        return cv2.GaussianBlur(image, (kernel_size, kernel_size), sigma)

    def _add_gaussian_noise(self, image: np.ndarray, std: float) -> np.ndarray:
        noise = np.random.normal(0, std, image.shape).astype(np.float32)
        noisy_image = image.astype(np.float32) + noise
        return np.clip(noisy_image, 0, 255).astype(np.uint8)

    def _jpeg_compression(self, image: np.ndarray, quality: int) -> np.ndarray:
        encode_param = [int(cv2.IMWRITE_JPEG_QUALITY), quality]
        _, encoded_img = cv2.imencode('.jpg', image, encode_param)
        return cv2.imdecode(encoded_img, cv2.IMREAD_COLOR)

    def apply_degradation(self, image: np.ndarray, mode: str = 'BicC', scale_factor: int = 8) -> np.ndarray:
        image = self._resize_image(image)
        h, w = image.shape[:2]

        if mode == 'BicC':
            downsampled = cv2.resize(image, (w//scale_factor, h//scale_factor), interpolation=cv2.INTER_CUBIC)
            upsampled = cv2.resize(downsampled, (w, h), interpolation=cv2.INTER_CUBIC)
            quality = random.randint(90, 95)
            return self._jpeg_compression(upsampled, quality)

        elif mode == 'BicN':
            downsampled = cv2.resize(image, (w//scale_factor, h//scale_factor), interpolation=cv2.INTER_CUBIC)
            upsampled = cv2.resize(downsampled, (w, h), interpolation=cv2.INTER_CUBIC)
            noise_std = random.uniform(20, 25)
            return self._add_gaussian_noise(upsampled, noise_std)

        elif mode == 'BBilN':
            sigma = random.uniform(5, 7)
            blurred = self._apply_gaussian_blur(image, sigma=sigma)
            downsampled = cv2.resize(blurred, (w//scale_factor, h//scale_factor), interpolation=cv2.INTER_LINEAR)
            upsampled = cv2.resize(downsampled, (w, h), interpolation=cv2.INTER_LINEAR)
            noise_std = random.uniform(10, 15)
            return self._add_gaussian_noise(upsampled, noise_std)

        else:
            raise ValueError(f"Unknown degradation mode: {mode}")

    def process_ffhq_images(self):
        modes = ['BicC', 'BicN', 'BBilN']
        image_paths = glob(os.path.join(self.ffhq_path, '*'))

        for mode in modes:
            output_dir = os.path.join(self.output_path, mode)
            os.makedirs(output_dir, exist_ok=True)

            print(f"Processing mode: {mode}")
            for img_path in image_paths:
                img = cv2.imread(img_path)
                if img is None:
                    print(f"Skipping {img_path}, could not read.")
                    continue
                degraded = self.apply_degradation(img, mode=mode)
                filename = os.path.basename(img_path)
                cv2.imwrite(os.path.join(output_dir, filename), degraded)

if __name__ == "__main__":
    degrader = DegradationModels()
    degrader.process_ffhq_images()
\end{lstlisting}

\subsection*{Code for colour degradation}

\begin{lstlisting}[language=Python]
from PIL import Image
import os
from glob import glob

# Settings
input_folder = "inputs/originals"
output_folder = "inputs/degraded_mediancut"
num_colors = 6  # Number of colors for Median Cut

# Create output directory if it doesn't exist
os.makedirs(output_folder, exist_ok=True)

# Get all image paths from ffhq folder
image_paths = glob(os.path.join(input_folder, "*"))

# Process each image
for path in image_paths:
    try:
        # Load image
        original = Image.open(path).convert("RGB")

        # Apply Median Cut quantization
        degraded = original.quantize(colors=num_colors, method=0)

        # Convert back to RGB and save
        degraded_rgb = degraded.convert("RGB")
        filename = os.path.basename(path)
        degraded_rgb.save(os.path.join(output_folder, filename))

        print(f"Processed and saved: {filename}")
    except Exception as e:
        print(f"Failed to process {path}: {e}")
\end{lstlisting}
\begin{lstlisting}[language=Python]
import cv2
import numpy as np
from sklearn.cluster import KMeans
import os
from tqdm import tqdm

def degrade_color_palette(image, num_colors=8):
    """Degrade the color palette of a single image."""
    h, w, _ = image.shape
    img_reshaped = image.reshape((-1, 3))

    # Apply k-means to extract dominant colors (palette)
    kmeans = KMeans(n_clusters=num_colors, random_state=42).fit(img_reshaped)
    palette = np.uint8(kmeans.cluster_centers_)
    labels = kmeans.predict(img_reshaped)

    # Reconstruct degraded image from palette
    degraded = palette[labels].reshape((h, w, 3))
    return degraded

def process_folder(input_folder, output_folder, num_colors=8):
    """
    Process all images in a folder and save degraded versions in an output folder.

    Args:
        input_folder: Path to the folder containing input images
        output_folder: Path to save degraded images
        num_colors: Number of colors to use in the degraded palette
    """
    # Create output folder if it doesn't exist
    os.makedirs(output_folder, exist_ok=True)

    # Get all image files in the input folder
    image_files = [f for f in os.listdir(input_folder) if f.lower().endswith(('.png', '.jpg', '.jpeg'))]

    # Process each image
    for filename in tqdm(image_files, desc="Processing images"):
        # Load image
        img_path = os.path.join(input_folder, filename)
        img = cv2.imread(img_path)
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

        # Apply color degradation
        degraded = degrade_color_palette(img, num_colors=num_colors)

        # Save degraded image
        output_path = os.path.join(output_folder, filename)
        cv2.imwrite(output_path, cv2.cvtColor(degraded, cv2.COLOR_RGB2BGR))

# Example usage
input_folder = "inputs/originals"  # Folder containing original images
output_folder = "inputs/degraded_kmeans"  # Folder to save degraded images
num_colors = 6  # Number of colors in the degraded palette

process_folder(input_folder, output_folder, num_colors=num_colors)
print(f"Degraded images saved to {output_folder}")

\end{lstlisting}
\end{sloppypar}
